SymbolicRegression
------------------
Simple experiment on Symbolic Regression. Given a set of samples for the variable "t" and the variable "y" (in the csv file "data.csv"), ugp3 will try to find an equation "y=f(t)" that best fits the data. The function on which the data are sampled is "y=sin^2(t)", and since there is no "pow" function defined, the optimal individual is "y=sin(t)*sin(t)". Note that ugp3 could also find equivalent equations, such as "y=(((t)-(t))-(sin(t)))*(((t)-(t))-(sin(t)))"

The structure of an individual, described in "symbolic-regression.constraints.xml", is essentially a binary tree, described by a linear graph. For example, an individual like:

1. # Root of the tree is
2. nodeCGT
3. # End of subsection prologue
4. nodeCGT:nodeCGV * nodeCGV
5. cos nodeCGV
6. nodeCGV:sin nodeCGW
7. nodeCGW:t

corresponds to the expression sin(t) * sin(t). To obtain the expression, the evaluator follows all the links, starting from the root on line 2, to line 4 (nodeCGV * nodeCGV), to line 6 (sin(nodeCGW) * sin(nodeCGW)), to line 7 (sin(t) * sin(t)). Note that some of the nodes can be non-expressed, e.g. they are not referred to by any other line: for example, the node on line 5.

Since this is a minimization problem (reduce the difference between the points of data and those produced by the candidate function), and ugp3 always maximizes the fitness values, the fitness is defined as follows:
	i. (BIG_NUMBER - difference_first_derivative) , trying to evaluate the difference between the first derivative of the function and the first derivative of the data; 
	ii. (BIG_NUMBER - difference) , evaluates the difference between the data points produced by the function and the provided data;
	iii. (BIG_NUMBER - tree_nodes) , pushes for smaller expressions, trying to minimize the number of nodes in the tree;
	iv. (tree_nodes / (tree_nodes + invalid_nodes) ) , pushes for trees with as many expressed nodes as possible.
A commentary is added to the fitness values, in order to help the user understand the progression of the evolution.

The experiment is very trivial, and intends to just hint at the different possible uses of ugp3. If you are especially interested in the Symbolic Regression problem, the current state-of-the-art is the sophisticated GP-based software Eureqa, developed by researchers of Nutonian, a spinoff of Cornell University (http://www.nutonian.com/)

Files in this folder
--------------------
cleanup.sh					# simple script that removes all files generated by ugp3, 
						  leaving the bare minimum needed to run the sample
data.csv					# csv file with the data used for the symbolic regression
evaluator.cpp					# evaluator for the problem (written in C++)
launch.sh					# Unix shell script that compiles the evaluator and launches the experiment
symbolic-regression.constraints.xml		# constraints for this sample
symbolic-regression.population.settings.xml	# population settings for ugp3
README.txt					# this file :-D
ugp3.settings.xml				# general settings for ugp3

Running SymbolicRegression
--------------------------
If you're working on Linux, and you have the g++ compiler and ugp3 installed, you can simply type "./launch.sh" : the script will compile the evaluator and start ugp3 inside this folder. Otherwise, you need to compile "evaluator.cpp" in order to obtain an "evaluator" executable, and then run ugp3 inside this folder.
