/*===============================================================================
 * CEC07 MO Test function suite 
 * 

 * Compile:
 * for linux:  
 *      gcc -c fsuite.c
 *      ld -o fsuite.so -shared fsuite.o
 * 	
 * for windows: 	  
 * 		gcc -c fsuite.c -DWINDOWS
 * 		dllwrap -o fsuite.dll fsuite.o
 *
 *
 *
 *	Huang Ling (email: huangling@pmail.ntu.edu.sg) 
 *	Time-stamp: "2007-01-23 "
 *
 * Modification ("2007-02-01")
 * Add 30D on R_ZDT4, and R_DTLZ2.

 * Modification("2007-04-02")
 * for WFG problem, "k=4" -> "k=M==2?4:2*(M-1)";
 *===============================================================================
 */

#ifdef WINDOWS
#define DLLIMPORT __declspec (dllexport)
#else
#define DLLIMPORT
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define a 1
#define b 10
#define c 8
#define c1 (a+c/2)
#define c2 (c+2*a)
#define b1 (b/2)
#define PI  3.1415926535897932384626433832795

DLLIMPORT void OKA2(double *x, double *f,int nx,int n_obj)
{	
	f[0] = x[0];	
	f[1] = 1 - pow((x[0]+PI),2)/(4*pow(PI,2)) + pow(abs(x[1]-5*cos(x[0])),1.0/3.0)+ pow(abs(x[2]-5*sin(x[0])),1.0/3.0);
}


/* these variables are needed to speed up rotation */
void findTile(double x1, double x2, int *t1, int *t2) 
{
	double xx1 = (x1 < 0) ? -x1 : x1;
	double xx2 = (x2 < 0) ? -x2 : x2;
	*t1 = (xx1 < c1) ? 0 : ((int)ceil((xx1-c1)/c2));
	*t2 = (xx2 < b1) ? 0 : ((int)ceil((xx2-b1)/b));
	if (x1 < 0) *t1 = -(*t1);
	if (x2 < 0) *t2 = -(*t2);
}
/* returns tile number between 0 and 8
returns - 1 if out of any tile, function does
not depend on objFct! */
int findTileSYMPART(double x1, double x2) 
{
	int i, j,dim;
	double x[2],h1;	
	double omega =  PI / 4.0;
	double si = sin(omega), co = cos(omega);
	x[0] = x1;
	x[1] = x2;
	//rotate( 2, x );
	for( dim=0; dim+1 < 2; dim+=2 ) 
	{
		h1 = x[dim];
		x[dim] = co * h1 - si * x[dim+1];
		x[dim+1] = si * h1 + co * x[dim+1];
	}
	findTile(x[0], x[1], &i, &j);
	// restrict to 9 tiles
	if (abs(i) > 1 || abs(j) > 1) return -1;
	return (i + 1) * 3 + (j + 1);
}

DLLIMPORT void SYMPART(double *x, double *f,int nx,int n_obj)
{
	double omega =  PI / 4.0;
	double si = sin(omega), co = cos(omega);
	// copy array to preserve original values
	double *localX = (double*)malloc(nx * sizeof (double));
	memcpy( localX, x, nx * sizeof (double) );
	int dim;
	double h1;
	// hide original x
	x = localX;
	//rotate( nx, x );
	for( dim=0; dim+1 < nx; dim+=2 ) 
	{
		h1 = x[dim];
		x[dim] = co * h1 - si * x[dim+1];
		x[dim+1] = si * h1 + co * x[dim+1];
	}
	double x1 = *x, x2 = *(x+1);
	int i, j,xnum;
	// find tile
	findTile(x1, x2, &i, &j);
	// restrict to 9 tiles
	if (i > 1) i = 1; else if (i < -1) i = -1;
	if (j > 1) j = 1; else if (j < -1) j = -1;
	// get values
	f[0] = 0;
	f[1] = 0;
	for( xnum=0; xnum<nx; xnum++ )
	{
		x1 = *(x+xnum);
		//printf("FLOOP: %d : %g \n", xnum, x1 );
		if( (xnum % 2) == 0 )
		{
			f[0] += pow(x1+a-i*c2,2);
			f[1] += pow(x1-a-i*c2,2);
		} 
		else 
		{
			f[0] += pow(x1-j*b,2);
			f[1] += pow(x1-j*b,2);
		}
	}
	f[0] /= nx;
	f[1] /= nx;
	free( localX );	
}

DLLIMPORT void S_ZDT1(double *x, double *f,int nx,int n_obj)
{
	double g;
	double sum=0,psum=0,flag=0;	
	double z[nx],zz[nx],p[nx];
	int i;	
	double o[100]={0.950, 0.231, 0.607, 0.486, 0.891, 0.762, 0.457, 0.019, 0.821, 0.445, 0.615, 0.792, 0.922, 0.738, 0.176, 0.406, 0.936, 0.917, 0.410, 0.894, 0.058, 0.353, 0.813, 0.010, 0.139, 0.203, 0.199, 0.604, 0.272, 0.199, 0.015, 0.747, 0.445, 0.932, 0.466, 0.419, 0.846, 0.525, 0.203, 0.672, 0.838, 0.020, 0.681, 0.380, 0.832, 0.503, 0.710, 0.429, 0.305, 0.190, 0.193, 0.682, 0.303, 0.542, 0.151, 0.698, 0.378, 0.860, 0.854, 0.594, 0.497, 0.900, 0.822, 0.645, 0.818, 0.660, 0.342, 0.290, 0.341, 0.534, 0.727, 0.309, 0.839, 0.568, 0.370, 0.703, 0.547, 0.445, 0.695, 0.621, 0.795, 0.957, 0.523, 0.880, 0.173, 0.980, 0.271, 0.252, 0.876, 0.737, 0.137, 0.012, 0.894, 0.199, 0.299, 0.661, 0.284, 0.469, 0.065, 0.988};
	double d_l[100]={0.155, 0.119, 0.185, 0.064, 0.070, 0.203, 0.166, 0.151, 0.219, 0.083, 0.161, 0.057, 0.169, 0.072, 0.135, 0.114, 0.241, 0.129, 0.230, 0.181, 0.195, 0.058, 0.152, 0.107, 0.119, 0.219, 0.203, 0.212, 0.126, 0.238, 0.164, 0.236, 0.086, 0.087, 0.188, 0.244, 0.146, 0.124, 0.218, 0.196, 0.120, 0.140, 0.120, 0.207, 0.205, 0.114, 0.107, 0.228, 0.097, 0.208, 0.105, 0.120, 0.135, 0.196, 0.183, 0.111, 0.081, 0.236, 0.183, 0.171, 0.063, 0.160, 0.246, 0.091, 0.064, 0.188, 0.222, 0.082, 0.174, 0.114, 0.155, 0.209, 0.179, 0.130, 0.184, 0.200, 0.108, 0.143, 0.116, 0.155, 0.078, 0.189, 0.128, 0.171, 0.168, 0.226, 0.061, 0.250, 0.201, 0.226, 0.065, 0.194, 0.114, 0.159, 0.135, 0.239, 0.167, 0.204, 0.095, 0.091};
    double lamda_l[100]={3.236, 4.201, 2.701, 7.775, 7.148, 2.465, 3.020, 3.322, 2.285, 6.004, 3.106, 8.801, 2.956, 6.918, 3.708, 4.403, 2.077, 3.884, 2.171, 2.760, 2.567, 8.636, 3.299, 4.666, 4.208, 2.285, 2.469, 2.362, 3.963, 2.099, 3.052, 2.120, 5.809, 5.753, 2.654, 2.053, 3.427, 4.046, 2.297, 2.548, 4.151, 3.577, 4.165, 2.417, 2.445, 4.405, 4.668, 2.192, 5.147, 2.398, 4.743, 4.157, 3.710, 2.553, 2.733, 4.519, 6.159, 2.121, 2.738, 2.926, 7.918, 3.130, 2.034, 5.495, 7.846, 2.666, 2.253, 6.068, 2.881, 4.388, 3.220, 2.389, 2.791, 3.832, 2.711, 2.496, 4.624, 3.505, 4.297, 3.223, 6.428, 2.644, 3.920, 2.917, 2.978, 2.215, 8.138, 2.000, 2.490, 2.215, 7.711, 2.574, 4.395, 3.135, 3.705, 2.091, 3.003, 2.456, 5.241, 5.499};
	
	for(i=0;i<nx;i++)
	{		
		z[i]=x[i]-o[i];
	}
	
	if ( z[0]>=0)
	{		
		zz[0]=z[0];
		f[0]=zz[0]+1;
	}
	else
	{		
		zz[0]= -lamda_l[0] * z[0];		
		f[0] = 2.0/(1+exp(z[0]/d_l[0])) * (zz[0]+1);	
	}
	
	for(i=1;i<nx;i++)
	{	
		p[i]=0;
		zz[i]=z[i];
		if (z[i]<0)
		{			
			zz[i]= -lamda_l[i] * z[i];	
			p[i]= -z[i]/d_l[i];			
		}		
		sum+=zz[i];
		psum = sqrt(pow(psum,2) + pow(p[i],2));
	}
	g = 1+9*sum/(nx-1);
	f[1]=  (g *(1-sqrt(zz[0]/g)) + 1) * (2.0/(1+exp(-psum)));	
}



DLLIMPORT void S_ZDT2(double *x, double *f,int nx,int n_obj)
{
	double g;
	double sum=0,psum=0;	
	double z[nx],zz[nx],p[nx];
	int i;	
	double o[100]={0.583, 0.424, 0.516, 0.334, 0.433, 0.226, 0.580, 0.760, 0.530, 0.641, 0.209, 0.380, 0.783, 0.681, 0.461, 0.568, 0.794, 0.059, 0.603, 0.050, 0.415, 0.305, 0.874, 0.015, 0.768, 0.971, 0.990, 0.789, 0.439, 0.498, 0.214, 0.643, 0.320, 0.960, 0.727, 0.412, 0.745, 0.268, 0.440, 0.933, 0.683, 0.213, 0.839, 0.629, 0.134, 0.207, 0.607, 0.630, 0.370, 0.575, 0.451, 0.044, 0.027, 0.313, 0.013, 0.384, 0.683, 0.093, 0.035, 0.612, 0.609, 0.016, 0.016, 0.190, 0.587, 0.058, 0.368, 0.631, 0.718, 0.693, 0.084, 0.454, 0.442, 0.353, 0.154, 0.676, 0.699, 0.728, 0.478, 0.555, 0.121, 0.451, 0.716, 0.893, 0.273, 0.255, 0.866, 0.232, 0.805, 0.908, 0.232, 0.239, 0.050, 0.078, 0.641, 0.191, 0.844, 0.174, 0.171, 0.994};
	double d_l[100]={0.155, 0.119, 0.185, 0.064, 0.070, 0.203, 0.166, 0.151, 0.219, 0.083, 0.161, 0.057, 0.169, 0.072, 0.135, 0.114, 0.241, 0.129, 0.230, 0.181, 0.195, 0.058, 0.152, 0.107, 0.119, 0.219, 0.203, 0.212, 0.126, 0.238, 0.164, 0.236, 0.086, 0.087, 0.188, 0.244, 0.146, 0.124, 0.218, 0.196, 0.120, 0.140, 0.120, 0.207, 0.205, 0.114, 0.107, 0.228, 0.097, 0.208, 0.105, 0.120, 0.135, 0.196, 0.183, 0.111, 0.081, 0.236, 0.183, 0.171, 0.063, 0.160, 0.246, 0.091, 0.064, 0.188, 0.222, 0.082, 0.174, 0.114, 0.155, 0.209, 0.179, 0.130, 0.184, 0.200, 0.108, 0.143, 0.116, 0.155, 0.078, 0.189, 0.128, 0.171, 0.168, 0.226, 0.061, 0.250, 0.201, 0.226, 0.065, 0.194, 0.114, 0.159, 0.135, 0.239, 0.167, 0.204, 0.095, 0.091};
	double lamda_l[100]={3.236, 4.201, 2.701, 7.775, 7.148, 2.465, 3.020, 3.322, 2.285, 6.004, 3.106, 8.801, 2.956, 6.918, 3.708, 4.403, 2.077, 3.884, 2.171, 2.760, 2.567, 8.636, 3.299, 4.666, 4.208, 2.285, 2.469, 2.362, 3.963, 2.099, 3.052, 2.120, 5.809, 5.753, 2.654, 2.053, 3.427, 4.046, 2.297, 2.548, 4.151, 3.577, 4.165, 2.417, 2.445, 4.405, 4.668, 2.192, 5.147, 2.398, 4.743, 4.157, 3.710, 2.553, 2.733, 4.519, 6.159, 2.121, 2.738, 2.926, 7.918, 3.130, 2.034, 5.495, 7.846, 2.666, 2.253, 6.068, 2.881, 4.388, 3.220, 2.389, 2.791, 3.832, 2.711, 2.496, 4.624, 3.505, 4.297, 3.223, 6.428, 2.644, 3.920, 2.917, 2.978, 2.215, 8.138, 2.000, 2.490, 2.215, 7.711, 2.574, 4.395, 3.135, 3.705, 2.091, 3.003, 2.456, 5.241, 5.499};	
	
	for(i=0;i<nx;i++)
	{		
		z[i]=x[i]-o[i];
	}
	
	if ( z[0]>=0)
	{		
		zz[0]=z[0];
		f[0]=zz[0]+1;
	}
	else
	{		
		zz[0]= -lamda_l[0] * z[0];		
		f[0] = 2.0/(1+exp(z[0]/d_l[0])) * (zz[0]+1);
	}
	
	for(i=1;i<nx;i++)
	{
		p[i]=0;
		zz[i]=z[i];
		if (z[i]<0)
		{
			zz[i]= -lamda_l[i] * z[i];	
			p[i]= -z[i]/d_l[i];
		}
		sum+=zz[i];
		psum = sqrt(pow(psum,2) + pow(p[i],2));
	}
	g = 1+9*sum/(nx-1);
	f[1] =  (g * (1 - pow(zz[0]/g, 2)) + 1) * (2.0/(1+exp(-psum)));	
}

DLLIMPORT void S_ZDT4(double *x, double *f,int nx,int n_obj)
{
	double g;
	double sum=0,psum=0;	
	double z[nx],zz[nx],p[nx];
	int i;
	double o[100]={0.957, 0.436, 2.092, 5.523, 5.686, 3.616, 1.646, 9.461, 0.881, 7.606, 4.401, 4.251, 5.182, 6.320, 9.136, 9.871, 7.308, 6.021, 1.941, 0.640, 0.581, 4.970, 4.677, 4.436, 3.997, 1.971, 0.071, 8.880, 9.464, 4.152, 1.318, 4.620, 9.296, 2.804, 9.034, 1.787, 5.197, 7.792, 5.364, 7.301, 0.953, 6.922, 5.955, 5.000, 1.437, 1.800, 2.796, 2.448, 0.499, 2.813, 3.784, 5.816, 7.544, 9.607, 0.634, 7.079, 6.864, 9.367, 2.498, 3.362, 5.484, 8.693, 2.720, 0.246, 1.878, 7.354, 4.399, 8.886, 1.394, 4.045, 7.694, 1.343, 4.430, 4.077, 1.512, 5.488, 7.547, 3.081, 7.321, 7.537, 3.430, 1.710, 9.287, 3.121, 5.341, 1.471, 5.165, 3.627, 7.946, 1.710, 9.013, 7.844, 9.240, 6.567, 4.996, 3.462, 1.847, 2.767, 9.231, 8.492};
	double d_l[100]={0.099, 1.905, 2.486, 1.323, 0.823, 1.519, 1.737, 1.969, 2.072, 1.949, 1.812, 1.895, 0.571, 2.378, 1.079, 0.673, 1.300, 1.929, 2.052, 1.499, 2.282, 1.721, 0.675, 1.275, 1.282, 2.080, 1.178, 1.539, 2.319, 0.672, 1.243, 0.883, 0.939, 2.239, 1.249, 1.833, 1.154, 1.773, 1.743, 2.152, 2.445, 1.783, 0.753, 1.610, 1.248, 0.749, 0.703, 1.544, 2.203, 2.355, 1.373, 1.570, 1.330, 0.834, 1.183, 0.731, 1.142, 1.991, 2.101, 1.163, 1.817, 0.849, 1.631, 0.934, 1.672, 1.313, 1.488, 0.826, 1.907, 2.250, 0.676, 0.593, 1.953, 0.699, 1.340, 1.880, 0.690, 1.655, 1.804, 2.296, 1.826, 0.856, 1.924, 1.652, 1.501, 0.903, 1.852, 1.661, 2.351, 2.107, 1.819, 0.574, 0.803, 1.662, 2.390, 2.402, 1.007, 0.654, 1.845, 2.116};
	double lamda_l[100]={5.055, 2.625, 2.011, 3.779, 6.077, 3.291, 2.878, 2.540, 2.413, 2.566, 2.760, 2.639, 8.752, 2.103, 4.633, 7.434, 3.847, 2.592, 2.437, 3.336, 2.191, 2.905, 7.409, 3.922, 3.901, 2.404, 4.245, 3.249, 2.156, 7.441, 4.024, 5.665, 5.327, 2.233, 4.003, 2.727, 4.334, 2.820, 2.869, 2.323, 2.045, 2.804, 6.644, 3.105, 4.007, 6.676, 7.116, 3.238, 2.269, 2.123, 3.642, 3.185, 3.759, 5.997, 4.228, 6.837, 4.378, 2.512, 2.380, 4.299, 2.752, 5.893, 3.066, 5.353, 2.990, 3.808, 3.360, 6.055, 2.622, 2.222, 7.394, 8.426, 2.560, 7.155, 3.732, 2.660, 7.246, 3.022, 2.772, 2.178, 2.738, 5.842, 2.599, 3.026, 3.332, 5.538, 2.700, 3.010, 2.126, 2.374, 2.748, 8.707, 6.230, 3.008, 2.092, 2.081, 4.963, 7.649, 2.710, 2.363};
	
	for(i=0;i<nx;i++)
	{		
		z[i]=x[i]-o[i];
	}
	
	if ( z[0]>=0)
	{		
		zz[0]=z[0];
		f[0]=zz[0]+1;
		p[0]=0;
	}
	else
	{		
		zz[0]= -lamda_l[0] * z[0];	
		p[0] = -z[0]/d_l[0];
		f[0] = 2.0/(1+exp(-p[0])) * (zz[0]+1);;	
	}
	
	for (i = 1; i < nx; i++)
	{	
		p[i]=0;
		zz[i]=z[i];
		if (z[i]<-5)
		{
			zz[i]=-5-lamda_l[i] * (5+z[i]);	
			p[i]=(-5-z[i])/d_l[i];			
		}
		sum+= zz[i] * zz[i] - 10 * cos(4 * PI * zz[i]);
		psum = sqrt(pow(psum,2) + pow(p[i],2));	
	}
	g = 1 + 10 * (nx - 1) + sum;    
	f[1] = (g * (1 - sqrt(zz[0] / g)) + 1) * (2.0/(1+exp(-psum)));	
}

DLLIMPORT void S_ZDT6(double *x, double *f,int nx,int n_obj)
{	
	double g;
	double sum=0,psum=0;	
	double z[nx],zz[nx],p[nx];
	int i;
	double o[100] ={0.360, 0.549, 0.262, 0.597, 0.049, 0.571, 0.701, 0.962, 0.751, 0.740, 0.432, 0.634, 0.803, 0.084, 0.945, 0.916, 0.602, 0.254, 0.873, 0.513, 0.733, 0.422, 0.961, 0.072, 0.553, 0.292, 0.858, 0.336, 0.680, 0.053, 0.357, 0.498, 0.434, 0.562, 0.617, 0.113, 0.898, 0.755, 0.791, 0.815, 0.670, 0.201, 0.273, 0.626, 0.537, 0.060, 0.089, 0.271, 0.409, 0.474, 0.909, 0.596, 0.329, 0.478, 0.597, 0.161, 0.829, 0.956, 0.596, 0.029, 0.812, 0.610, 0.701, 0.092, 0.425, 0.376, 0.166, 0.833, 0.839, 0.452, 0.957, 0.147, 0.870, 0.769, 0.444, 0.621, 0.952, 0.640, 0.247, 0.353, 0.188, 0.491, 0.409, 0.464, 0.611, 0.071, 0.314, 0.608, 0.175, 0.621, 0.246, 0.587, 0.506, 0.465, 0.541, 0.942, 0.342, 0.402, 0.308, 0.412};
	double d_l[100]={0.155, 0.119, 0.185, 0.064, 0.070, 0.203, 0.166, 0.151, 0.219, 0.083, 0.161, 0.057, 0.169, 0.072, 0.135, 0.114, 0.241, 0.129, 0.230, 0.181, 0.195, 0.058, 0.152, 0.107, 0.119, 0.219, 0.203, 0.212, 0.126, 0.238, 0.164, 0.236, 0.086, 0.087, 0.188, 0.244, 0.146, 0.124, 0.218, 0.196, 0.120, 0.140, 0.120, 0.207, 0.205, 0.114, 0.107, 0.228, 0.097, 0.208, 0.105, 0.120, 0.135, 0.196, 0.183, 0.111, 0.081, 0.236, 0.183, 0.171, 0.063, 0.160, 0.246, 0.091, 0.064, 0.188, 0.222, 0.082, 0.174, 0.114, 0.155, 0.209, 0.179, 0.130, 0.184, 0.200, 0.108, 0.143, 0.116, 0.155, 0.078, 0.189, 0.128, 0.171, 0.168, 0.226, 0.061, 0.250, 0.201, 0.226, 0.065, 0.194, 0.114, 0.159, 0.135, 0.239, 0.167, 0.204, 0.095, 0.091};
	double lamda_l[100]={3.236, 4.201, 2.701, 7.775, 7.148, 2.465, 3.020, 3.322, 2.285, 6.004, 3.106, 8.801, 2.956, 6.918, 3.708, 4.403, 2.077, 3.884, 2.171, 2.760, 2.567, 8.636, 3.299, 4.666, 4.208, 2.285, 2.469, 2.362, 3.963, 2.099, 3.052, 2.120, 5.809, 5.753, 2.654, 2.053, 3.427, 4.046, 2.297, 2.548, 4.151, 3.577, 4.165, 2.417, 2.445, 4.405, 4.668, 2.192, 5.147, 2.398, 4.743, 4.157, 3.710, 2.553, 2.733, 4.519, 6.159, 2.121, 2.738, 2.926, 7.918, 3.130, 2.034, 5.495, 7.846, 2.666, 2.253, 6.068, 2.881, 4.388, 3.220, 2.389, 2.791, 3.832, 2.711, 2.496, 4.624, 3.505, 4.297, 3.223, 6.428, 2.644, 3.920, 2.917, 2.978, 2.215, 8.138, 2.000, 2.490, 2.215, 7.711, 2.574, 4.395, 3.135, 3.705, 2.091, 3.003, 2.456, 5.241, 5.499};	
	
	for(i=0;i<nx;i++)
	{		
		z[i]=x[i]-o[i];
	}
	
	if ( z[0]>=0)
	{		
		zz[0]=z[0];
		f[0]=1 - exp(-4.0 *zz[0]) *pow(sin(6.0*PI*zz[0]),6)+1;
	}
	else
	{		
		zz[0]= -lamda_l[0] * z[0];		
		f[0] =  2.0/(1+exp(z[0]/d_l[0])) * (1 - exp(-4.0 *zz[0]) *pow(sin(6.0*PI*zz[0]),6) +1);	
	}
		
	for(i=1;i<nx;i++)
	{	
		p[i]=0;
		zz[i]=z[i];
		if (z[i]<0)
		{
			zz[i]=-lamda_l[i] * z[i];	
			p[i]=-z[i]/d_l[i];
		}
		sum+=zz[i];	
		psum = sqrt(pow(psum,2) + pow(p[i],2));
	}	
	g = 1 + 9.0 * pow ( sum/(nx-1),0.25);
	f[1] =  (g * (1 - pow (( 1 - exp(-4.0 *zz[0]) * pow(sin(6.0*PI*zz[0]),6) )/g,2)) + 1 ) * (2.0/(1+exp(-psum)));
}

DLLIMPORT void S_DTLZ2(double *x, double *f,int nx,int n_obj)
{
	int i = 0;
	int j = 0;    
	int k = nx - n_obj + 1;
	double g = 0;
	double z[nx],zz[nx],p[nx],psum[n_obj];
	
	double o[30]={0.366, 0.303, 0.852, 0.759, 0.950, 0.558, 0.014, 0.596, 0.816, 0.977, 0.222, 0.704, 0.522, 0.933, 0.713, 0.228, 0.450, 0.172, 0.969, 0.356, 0.049, 0.755, 0.895, 0.286, 0.251, 0.933, 0.131, 0.941, 0.702, 0.848};
	double d_l[30]={0.155, 0.119, 0.185, 0.064, 0.07, 0.203, 0.166, 0.151, 0.219, 0.083, 0.161, 0.057, 0.169, 0.072, 0.135, 0.114, 0.241, 0.129, 0.23, 0.181, 0.195, 0.058, 0.152, 0.107, 0.119, 0.219, 0.203, 0.212, 0.126, 0.238};
	double lamda_l[30]={3.236, 4.201, 2.701, 7.775, 7.148, 2.465, 3.02, 3.322, 2.285, 6.004, 3.106, 8.801, 2.956, 6.918, 3.708, 4.403, 2.077, 3.884, 2.171, 2.76, 2.567, 8.636, 3.299, 4.666, 4.208, 2.285, 2.469, 2.362, 3.963, 2.099};
	
	for(i=0;i<nx;i++)
	{	
		z[i]=x[i]-o[i];
		
		if (z[i]<0)
		{			
			zz[i]=-lamda_l[i] * z[i];	
			p[i]=-z[i]/d_l[i];
		}
		else
		{
			zz[i]=z[i];
			p[i]=0;
		}
	}	
	for(j=0;j<n_obj;j++)
	{
		psum[j] = 0;
	}
	for (i = nx - k + 1; i <= nx; i++)
	{
		g += pow(zz[i-1]-0.5,2);
		for(j=0;j<n_obj;j++)
		{
			psum[j]= sqrt(pow(psum[j],2) + pow(p[i-1],2));
		}
	}
	for (i = 1; i <= n_obj; i++)
	{		
		double ff = (1 + g);
		for (j = n_obj - i; j >= 1; j--)
		{
			ff *= cos(zz[j-1] * PI / 2.0);			
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[j-1],2) );
		}
		if (i > 1)
		{
			ff *= sin(zz[(n_obj - i + 1) - 1] * PI / 2.0);
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[(n_obj - i + 1) - 1],2) );
		}
		
		f[i-1] =  2.0/(1+exp(-psum[i-1])) * (ff+1);
	}
		  
}

DLLIMPORT void S_DTLZ3(double *x, double *f,int nx,int n_obj)
{
	int i = 0;
	int j = 0;
	int k = nx - n_obj + 1;
	double g = 0;
	double z[nx],zz[nx],p[nx],psum[n_obj];	
	double o[30]={0.209, 0.455, 0.081, 0.851, 0.562, 0.319, 0.375, 0.868, 0.372, 0.074, 0.200, 0.049, 0.567, 0.122, 0.522, 0.117, 0.770, 0.375, 0.823, 0.047, 0.598, 0.949, 0.289, 0.889, 0.102, 0.065, 0.234, 0.933, 0.063, 0.264};
	double d_l[30]={0.155, 0.119, 0.185, 0.064, 0.07, 0.203, 0.166, 0.151, 0.219, 0.083, 0.161, 0.057, 0.169, 0.072, 0.135, 0.114, 0.241, 0.129, 0.23, 0.181, 0.195, 0.058, 0.152, 0.107, 0.119, 0.219, 0.203, 0.212, 0.126, 0.238};
	double lamda_l[30]={3.236, 4.201, 2.701, 7.775, 7.148, 2.465, 3.02, 3.322, 2.285, 6.004, 3.106, 8.801, 2.956, 6.918, 3.708, 4.403, 2.077, 3.884, 2.171, 2.76, 2.567, 8.636, 3.299, 4.666, 4.208, 2.285, 2.469, 2.362, 3.963, 2.099};
					
	for(i=0;i<nx;i++)
	{	
		z[i]=x[i]-o[i];
		
		if (z[i]<0)
		{			
			zz[i]=-lamda_l[i] * z[i];	
			p[i]=-z[i]/d_l[i];
		}
		else
		{
			zz[i]=z[i];
			p[i]=0;
		}
	}	
	for(j=0;j<n_obj;j++)
	{
		psum[j] = 0;
	}
	
	for (i = nx - k + 1; i <= nx; i++)
	{
		g += pow(zz[i-1]-0.5,2) - cos(20 * PI * (zz[i-1]-0.5));
		for(j=0;j<n_obj;j++)
		{
			psum[j]= sqrt( pow(psum[j],2) + pow(p[i-1],2) );
		}
	}
	g = 100 * (k + g);
	for (i = 1; i <= n_obj; i++)
	{
		double ff = (1 + g);
		for (j = n_obj - i; j >= 1; j--)
		{
			ff *= cos(zz[j-1] * PI / 2.0);
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[j-1],2) );
		}
		if (i > 1)
		{
			ff *= sin(zz[(n_obj - i + 1) - 1] * PI / 2.0);
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[(n_obj - i + 1) - 1],2) );
		}
		
		f[i-1] = 2.0/(1+exp(-psum[i-1])) * (ff+1);
	}			
}


DLLIMPORT void R_ZDT4(double *x, double *f,int nx,int n_obj)
{
	int i = 0,j=0;    
	double g = 0;
	double sum = 0,psum=0;
	double z[nx],zz[nx],p[nx],M[nx][nx],lamda_l[nx];	
	double M_10D[10][10]={{0.522,-0.230,0.087,0.806,0.131,0,0,0,0,0},
	{0.009,0.648,-0.707,0.229,0.167,0,0,0,0,0},
	{0.404,0.391,0.160,-0.036,-0.811,0,0,0,0,0},
	{-0.455,-0.450,-0.448,0.303,-0.546,0,0,0,0,0},
	{-0.598,0.415,0.515,0.452,-0.016,0,0,0,0,0},
	{0,0,0,0,0,1,0,0,0,0},
	{0,0,0,0,0,0,1,0,0,0},
	{0,0,0,0,0,0,0,1,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,1}};
	double lamda_l_10D[10]={0.042,0.483,0.510,0.390,0.459,1,1,1,1,1};	
	
	double M_30D[30][30]={{-0.087,0.057,-0.403,0.349,0.114,-0.206,0.014,0.335,0.341,0.100,-0.504,-0.127,-0.230,-0.186,0.230,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.124,0.496,0.007,-0.121,-0.168,0.130,0.270,-0.210,0.222,0.135,0.232,-0.498,-0.013,-0.003,0.439,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.047,-0.215,-0.117,-0.107,-0.152,0.442,-0.229,-0.172,0.155,-0.591,-0.076,0.025,-0.048,-0.432,0.239,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.220,-0.082,0.078,-0.130,0.530,-0.100,0.123,-0.206,-0.071,0.048,-0.004,-0.382,-0.213,-0.489,-0.368,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.418,-0.423,-0.261,-0.271,-0.219,-0.449,-0.044,-0.134,0.263,0.065,0.304,-0.217,0.120,-0.089,-0.020,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.371,-0.463,0.229,0.087,0.312,-0.209,0.059,-0.074,0.027,0.093,0.049,0.111,0.191,0.060,0.612,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.034,-0.066,0.148,0.416,-0.178,-0.172,0.005,0.043,-0.172,-0.143,0.454,0.029,-0.682,-0.060,0.101,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.398,-0.152,0.434,-0.122,0.043,0.282,-0.437,0.056,-0.073,0.380,-0.198,-0.274,-0.208,0.023,0.178,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.010,-0.376,-0.311,-0.070,-0.099,0.497,0.508,0.147,-0.156,0.393,0.086,0.100,-0.133,-0.081,0.008,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.256,-0.066,0.423,-0.245,-0.181,0.003,0.101,0.511,0.564,0.003,0.085,0.087,-0.088,-0.093,-0.195,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.014,0.257,-0.063,-0.320,-0.081,-0.222,-0.139,0.395,-0.448,0.115,0.112,0.173,0.120,-0.510,0.256,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.381,0.121,0.040,-0.462,0.399,-0.062,0.332,0.020,0.037,-0.303,-0.071,0.246,-0.322,0.217,0.203,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.283,-0.162,-0.275,-0.214,0.069,0.033,-0.191,0.421,-0.237,-0.264,0.070,-0.481,-0.086,0.429,0.002,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.366,0.079,-0.309,-0.318,-0.022,-0.040,-0.398,-0.294,0.171,0.329,0.009,0.322,-0.398,0.127,-0.006,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{-0.171,0.138,-0.187,0.195,0.512,0.280,-0.264,0.204,0.266,0.067,0.556,0.105,0.175,-0.029,-0.002,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000,0.000},
	{0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.000}};

	double lamda_l_30D[30]={0.011,0.125,0.128,0.128,0.115,0.132,0.151,0.117,0.128,0.134,0.120,0.117,0.118,0.118,0.124,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000};
	

	//double M[4][4]={ {-0.17305,	0.98491},    {-0.98491,	-0.17305},{0 , 0,1.0},	{0  , 0,  0, 1.0}};
	//double  d_l[4]={1,10,1,1};
	//double lamda_l[4]={0.25,0.25,0.25,0.25};
	
	 if (nx==10)
	 {
		 for (i=0;i<nx;i++)
		 {
			 for (j=0;j<nx;j++)
				 M[i][j]=M_10D[i][j];	
			 lamda_l[i]=lamda_l_10D[i];
		 }
	 }
	 else 
	 {
		 for (i=0;i<nx;i++)
		 {
			 for (j=0;j<nx;j++)
				 M[i][j]=M_30D[i][j];	
			 lamda_l[i]=lamda_l_30D[i];
		 }
	 }
	 for (i=0;i<nx;i++)
	 {
		 z[i]=0;
		 for (j=0;j<nx;j++)
		 {
			 z[i]+=M[i][j]*x[j];
		 } 
	 }
	 if ( z[0]>=0 && z[0]<=1)
	 {		
		 zz[0]=z[0];
		 p[0]=0;
		 f[0]=zz[0]+1;	
	 }
	 else if(z[0]<0)
	 {		
		 zz[0]= -lamda_l[0] * z[0];	
		 p[0] = -z[0];
		 f[0] = 2.0/(1+exp(-p[0])) * (zz[0]+1);	
	 }
	 else
	 {
		 zz[0]= 1 - lamda_l[0] * (z[0]-1);	
		 p[0] = z[0]-1;
		 f[0] = 2.0/(1+exp(-p[0])) * (zz[0]+1);			
	 }
	 psum=p[0];
	 for (i = 1; i < nx; i++)
	 {			
		 if (z[i]>=-5 && z[i]<=5)
		 {
			 zz[i]=z[i];
			 p[i]=0;
		 }
		 else if (z[i]<-5)
		 {
			 zz[i]=-5-lamda_l[i] * (5+z[i]);	
			 p[i]=-5-z[i];			
		 }
		 else
		 {
			 zz[i]=5-lamda_l[i] * (z[i]-5);	
			 p[i]=z[i]-5;
		 }
		 sum+= zz[i] * zz[i] - 10 * cos(4 * PI * zz[i]);
		 psum = sqrt(pow(psum,2) + pow(p[i],2));	
	 }
	 g = 1 + 10 * (nx - 1) + sum;    
	 f[1] = (g * (1 - sqrt(zz[0] / g)) + 1) * (2.0/(1+exp(-psum)));				
}


DLLIMPORT void R_DTLZ2(double *x, double *f,int nx,int n_obj)
{	
	int i=0,j=0;    
	int k = nx - n_obj + 1;
	double g = 0;
	double sum = 0;
	double z[nx],zz[nx],p[nx],psum[n_obj],M[nx][nx],lamda_l[nx];
	double M_10D[10][10]={{-0.444,-0.380,-0.510,0.124,0.619,0,0,0,0,0},{0.214,-0.570,-0.445,0.239,-0.612,0,0,0,0,0},{-0.675,0.462,-0.336,-0.093,-0.458,0,0,0,0,0},{0.526,0.376,-0.644,-0.379,0.154,0,0,0,0,0},{0.160,0.419,-0.120,0.880,0.097,0,0,0,0,0},{0,0,0,0,0,1,0,0,0,0},{0,0,0,0,0,0,1,0,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,0,1}};
	double lamda_l_10D[10]={0.313,0.312,0.321,0.316,0.456,1,1,1,1,1};
	
	double M_30D[30][30]={{-0.376,0.392,-0.034,0.074,-0.124,-0.013,-0.430,0.168,0.144,0.334,0.054,-0.486,0.255,-0.081,0.163,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.202,-0.401,0.426,0.136,0.123,-0.437,-0.297,-0.182,0.417,0.119,0.150,0.190,-0.129,-0.026,0.085,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.218,-0.035,0.074,-0.107,-0.412,-0.093,0.659,0.181,0.291,0.148,-0.102,-0.082,-0.185,-0.200,0.300,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{0.053,-0.211,-0.173,-0.130,0.579,0.034,0.065,0.171,0.132,-0.143,-0.081,-0.311,-0.039,0.279,0.562,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.104,0.331,-0.031,-0.347,0.036,-0.345,0.077,0.236,0.130,-0.088,0.323,-0.020,-0.280,0.503,-0.340,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.219,-0.212,0.294,-0.514,-0.332,0.373,-0.264,0.050,-0.058,-0.428,0.134,0.006,0.062,0.047,0.155,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.165,0.324,0.386,-0.425,0.366,-0.075,0.033,-0.112,-0.335,0.261,-0.344,0.189,-0.100,-0.176,0.096,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.135,0.328,-0.066,0.268,0.062,0.093,0.011,-0.154,-0.203,-0.167,0.562,0.202,-0.360,-0.181,0.417,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{0.238,-0.064,0.093,0.111,-0.143,-0.131,-0.303,0.296,-0.185,-0.138,-0.272,-0.317,-0.655,-0.206,-0.041,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{0.623,0.161,0.259,-0.132,-0.110,0.340,-0.070,-0.132,0.288,0.413,0.165,-0.020,-0.137,0.175,0.146,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.008,-0.130,-0.578,-0.273,-0.154,-0.064,-0.313,0.199,0.028,0.305,-0.087,0.504,-0.119,-0.032,0.195,0,0,0,0,0,0,0,0,0,0,0,0,0,0.000,0.000},
	{-0.346,-0.347,0.078,0.209,-0.024,0.315,0.083,0.056,-0.381,0.452,0.069,-0.061,-0.231,0.425,-0.093,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0.168,-0.274,-0.170,-0.349,-0.098,-0.361,0.059,-0.355,-0.355,0.190,0.351,-0.392,0.068,-0.178,0.031,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0.259,0.026,0.291,0.178,-0.206,-0.358,0.011,0.419,-0.374,-0.001,0.059,0.182,0.363,0.237,0.326,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0.064,-0.173,0.104,-0.088,0.327,0.178,0.075,0.577,0.031,0.149,0.402,0.035,0.096,-0.463,-0.248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}};
	
    double lamda_l_30D[30]={0.113,0.105,0.117,0.119,0.108,0.110,0.101,0.107,0.111,0.109,0.120,0.108,0.101,0.105,0.116,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000};
	
	
	if (nx==10)
	{
		for (i=0;i<nx;i++)
		{
			for (j=0;j<nx;j++)
			{
				M[i][j]=M_10D[i][j];	
			}
			lamda_l[i]=lamda_l_10D[i];
		}
	}
	else 
	{
		for (i=0;i<nx;i++)
		{
			for (j=0;j<nx;j++)
			{
				M[i][j]=M_30D[i][j];	
			}
			lamda_l[i]=lamda_l_30D[i];
		}
	}
	
	for (i=0;i<nx;i++)
	{
		z[i]=0;
		for (j=0;j<nx;j++)
		{
			z[i]+=M[i][j]*x[j];
		}		
		if (z[i]>=0 && z[i]<=1)
		{
			zz[i]=z[i];
			p[i]=0;
		}
		else if (z[i]<0)
		{			
			zz[i]=-lamda_l[i] * z[i];	
			p[i]=-z[i];
		}
		else
		{
			zz[i]=1-lamda_l[i]*(z[i]-1);
			p[i]=z[i]-1;		
		}
	}	
	for(j=0;j<n_obj;j++)
	{
		psum[j] = 0;
	}
	
	for (i = nx - k + 1; i <= nx; i++)
	{
		g += pow(zz[i-1]-0.5,2) - cos(20 * PI * (zz[i-1]-0.5));
		for(j=0;j<n_obj;j++)
		{
			psum[j]= sqrt( pow(psum[j],2) + pow(p[i-1],2) );
		}
	}
	g = 100 * (k + g);
	for (i = 1; i <= n_obj; i++)
	{
		double ff = (1 + g);
		for (j = n_obj - i; j >= 1; j--)
		{
			ff *= cos(zz[j-1] * PI / 2.0);
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[j-1],2) );
		}
		if (i > 1)
		{
			ff *= sin(zz[(n_obj - i + 1) - 1] * PI / 2.0);
			psum[i-1] = sqrt( pow(psum[i-1],2) + pow(p[(n_obj - i + 1) - 1],2) );
		}
		
		f[i-1] = 2.0/(1+exp(-psum[i-1])) * (ff+1);
	}	
}


//// Implemented constants. /////////////////////////////////////////////////
#define EPSILON (1.0e-10)

double correct_to_01(double aa, double epsilon)
{		
	double min = 0.0, max = 1.0;	
    double min_epsilon = min - epsilon;
	double max_epsilon = max + epsilon;
	
	if ( aa <= min && aa >= min_epsilon )
	{
		return min;
	}
	else if ( aa >= max && aa <= max_epsilon )
	{
		return max;
	}
	else
	{
		return aa;
	}	
}

int vector_in_01( const double *x, int nx )
{
	int i;	
	for( i = 0; i < nx; i++ )
	{
		if( x[i] < 0.0 || x[i] > 1.0 )
		{
			return 0;
		}
	}	
	return 1;
}

//// Local functions/values. ////////////////////////////////////////////////
double linear( const double *x, const int m,int M )
{
	int i;		
	double result = 1.0;	
	for( i=1; i <= M-m; i++ )
	{
		result *= x[i-1];
	}
	
	if( m != 1 )
	{
		result *= 1 - x[M-m];
	}
	
	return correct_to_01( result, EPSILON );
}

double convex( const double *x, const int m,int M )
{
	int i;	
	double result = 1.0;	
	for( i=1; i <= M-m; i++ )
	{
		result *= 1.0 - cos( x[i-1]*PI/2.0 );
	}
	
	if( m != 1 )
	{
		result *= 1.0 - sin( x[M-m]*PI/2.0 );
	}
	
	return correct_to_01( result, EPSILON );
}

double concave( const double *x, const int m,int M )
{
	int i;
	double result = 1.0;
	
	for( i=1; i <= M-m; i++ )
	{
		result *= sin( x[i-1]*PI/2.0 );
	}
	
	if( m != 1 )
	{
		result *= cos( x[M-m]*PI/2.0 );
	}
	
	return correct_to_01( result, EPSILON );
}

double mixed( const double *x, const int A, const double  alpha )
{
	
	const double tmp = 2.0*A*PI;		
	return correct_to_01( pow( 1.0-x[0]-cos( tmp*x[0] + PI/2.0 )/tmp, alpha ), EPSILON );
}

double disc( const double *x, const int A, const double alpha, const double beta )
{
	
	const double tmp1 = A*pow( x[0], beta )*PI;
	return correct_to_01( 1.0 - pow( x[0], alpha )*pow( cos( tmp1 ), 2.0 ), EPSILON );
	
}


//** Calculate the minimum of two doubles. **********************************
static double min_double( const double aa, const double bb )
{
	return aa < bb ? aa : bb;
}


//// Implemented functions. /////////////////////////////////////////////////

double b_poly( const double y, const double alpha )
{
	return correct_to_01( pow( y, alpha ), EPSILON );
}

double b_flat
(
 const double y,
 const double A,
 const double B,
 const double C
 )
{	
	const double tmp1 = min_double( 0.0, floor( y-B ) ) * A*( B-y )/B;
	const double tmp2 = min_double( 0.0, floor( C-y ) ) * ( 1.0-A )*( y-C )/( 1.0-C );
	
	return correct_to_01( A+tmp1-tmp2, EPSILON );
}

double b_param
(
 const double y,
 const double u,
 const double A,
 const double B,
 const double C
 )
{
	const double v = A - ( 1.0-2.0*u )*fabs( floor( 0.5-u )+A );
	
	return correct_to_01( pow( y, B + ( C-B )*v ), EPSILON );
	
}

double s_linear( const double y, const double A )
{
	return correct_to_01( fabs( y-A )/fabs( floor( A-y )+A ), EPSILON );
}

double s_decept(const double y, const double A, const double B, const double C )
{
		const double tmp1 = floor( y-A+B )*( 1.0-C+( A-B )/B )/( A-B );
		const double tmp2 = floor( A+B-y )*( 1.0-C+( 1.0-A-B )/B )/( 1.0-A-B );
		
		return correct_to_01( 1.0 + ( fabs( y-A )-B )*( tmp1 + tmp2 + 1.0/B ), EPSILON );
	
}

double s_multi
(
 const double y,
 const int A,
 const double B,
 const double C
 )
{
		const double tmp1 = fabs( y-C )/( 2.0*( floor( C-y )+C ) );
		const double tmp2 = ( 4.0*A+2.0 )*PI*( 0.5-tmp1 );
		
		return correct_to_01( ( 1.0 + cos( tmp2 ) + 4.0*B*pow( tmp1, 2.0 ) )/( B+2.0 ), EPSILON );

}

double r_sum( const double *y, const double *w, int ny)
{
	
	int i;
	double numerator   = 0.0;
	double denominator = 0.0;
	
	for( i = 0; i < ny; i++ )
	{
		
		numerator   += w[i]*y[i];
		denominator += w[i];
	}
	
	return correct_to_01( numerator / denominator, EPSILON );
	
}

double r_nonsep( const double *y, const int A, int ny)
{
	const int y_len = ny;		
	int j;
	double numerator = 0.0;
	
	for( j = 0; j < y_len; j++ )
	{
		int k;		
		numerator += y[j];
		
		for( k = 0; k <= A-2; k++ )
		{
			numerator += fabs( y[j] - y[( j+k+1 ) % y_len] );
		}
	}
	
	{
	const double tmp = ceil( A/2.0 );
	const double denominator = y_len*tmp*( 1.0 + 2.0*A - 2.0*tmp )/A;
	
	return correct_to_01( numerator / denominator, EPSILON );
	}
}


DLLIMPORT void WFG1( double *z, double *f, int nx,  int M)
{	
	
	int i,j;	
	double y[30],t1[30],t2[30],t3[30],t4[5];
	const int k=M==2?4:2*(M-1);		

	for( i = 0; i < nx; i++ )
	{		
		y[i] = z[i] / (2.0*( i+1 ));
	}
	//y = WFG1_t1(y, k);
	for( i = 0; i < k; i++ )
	{
		t1[i] = y[i];
	}	
	for( i = k; i < nx; i++ )
	{
		t1[i] = s_linear( y[i], 0.35 );
	}
	
	
	//y = WFG1_t2(y, k);	
	for( i = 0; i < k; i++ )
	{
		t2[i] = t1[i];
	}
	
	for( i = k; i < nx; i++ )
	{
		t2[i] = b_flat( t1[i], 0.8, 0.75, 0.85 );
	}
	
	//y = WFG1_t3(y);	
	for( i = 0; i < nx; i++ )
	{
		t3[i] = b_poly( t2[i], 0.02 );
	}
	
	//y = WFG1_t4( y,k,M,nx);	
	
	{	
		double w[30];
		double y_sub[30],w_sub[30];	
		double y_sub2[30],w_sub2[30];
		
		for( i = 1; i <= nx; i++)
		{
			w[i-1] = 2.0*i;
		}
		
		for( i = 1; i <= M-1; i++ )
		{
			const int head = ( i-1 )*k/( M-1 );
			const int tail = i*k/( M-1 );
			
			for( j = head; j < tail; j++ )
			{
				y_sub[j-head] = t3[j];
				w_sub[j-head] = w[j];
			}		
			t4[i-1] = r_sum( y_sub, w_sub,tail-head );
		}	
		
		for( j = k; j < nx; j++ )
		{	
			y_sub2[j-k] = t3[j];
			w_sub2[j-k] = w[j];
		}	
		t4[i-1] = r_sum( y_sub2, w_sub2,nx-k );		
	}
	//shape
	{
		int  m;	
		short  A[5];
		double x[5],h[5],S[5];		
		
		A[0] = 1;	
		for( i = 1; i < M-1; i++ )
		{
			A[i] = 1;
		}
		for( i = 0; i < M-1; i++ )
		{
			double tmp1;		
			tmp1 = t4[M-1];
			if( A[i] > tmp1 )
				tmp1 = A[i];		
			x[i] = tmp1*( t4[i] - 0.5 ) + 0.5;
		}	
		x[M-1] = t4[M-1];
		
		for( m = 1; m <= M-1; m++ )
		{
			h[m-1] = convex( x, m,M );
		}
		h[m-1] = mixed( x, 5, 1.0 );
		
		for( m = 1; m <= M; m++ )
		{
			S[m-1] = m*2.0;
		}
		
		for( i = 0; i < M; i++ )
		{		
			f[i] = 1.0*x[M-1] + S[i]*h[i];
		}		
	}
}

DLLIMPORT void WFG8(double *z, double *f,int nx,int M)
{
	int i,j;	
	double y[30],t1[30],t2[30],t3[5];
	const int k=M==2?4:2*(M-1);
	
	for( i = 0; i < nx; i++ )
	{		
		y[i] = z[i] / (2.0*(i+1));
	}
	
	//y=WFG8_t1( y, k);
    for( i = 0; i < k; i++ )
	{
		t1[i] = y[i];
	}
	
	for( i = k; i < nx; i++ )
	{
		const int head = 0;
		const int tail = i;
		double y_sub[30],w_sub[30];	
		for( j = head; j < tail; j++ )
		{
			y_sub[j-head] = y[j];
			w_sub[j-head] = 1;
		}		
		{
			const double u = r_sum( y_sub, w_sub, tail-head );			
			t1[i] = b_param( y[i], u, 0.98/49.98, 0.02, 50 );
		}
		
	}
	
	//y=WFG1_t1( y, k);
	for( i = 0; i < k; i++ )
	{
		t2[i] = t1[i];
	}	
	for( i = k; i < nx; i++ )
	{
		t2[i] = s_linear( t1[i], 0.35 );
	}
	
	//y=WFG2_t3( y, k, M);
	{	
		double y_sub[30],w_sub[30];	
		double y_sub2[30],w_sub2[30];
		
		for( i = 1; i <= M-1; i++ )
		{
			const int head = ( i-1 )*k/( M-1 );
			const int tail = i*k/( M-1 );
			
			for( j = head; j < tail; j++ )
			{
				y_sub[j-head] = t2[j];
				w_sub[j-head] = 1;
			}		
			t3[i-1] = r_sum( y_sub, w_sub,tail-head );
		}	
		
		for( j = k; j < nx; j++ )
		{	
			y_sub2[j-k] = t2[j];
			w_sub2[j-k] = 1;
		}	
		t3[M-1] = r_sum( y_sub2, w_sub2,nx-k );		
	}
	
	//f_result=WFG4_shape(y);
	{
		int  m;	
		short  A[5];
		double x[5],h[5],S[5];		
		
		A[0] = 1;	
		for( i = 1; i < M-1; i++ )
		{
			A[i] = 1;
		}
		for( i = 0; i < M-1; i++ )
		{
			double tmp1;		
			tmp1 = t3[M-1];
			if( A[i] > tmp1 )
				tmp1 = A[i];		
			x[i] = tmp1*( t3[i] - 0.5 ) + 0.5;
		}	
		x[M-1] = t3[M-1];
		
		for( m = 1; m <= M; m++ )
		{
			h[m-1] = concave( x, m,M );
		}
		for( m = 1; m <= M; m++ )
		{
			S[m-1] = m*2.0;
		}
		
		for( i = 0; i < M; i++ )
		{		
			f[i] = 1.0*x[M-1] + S[i]*h[i];
		}		
	}
}

DLLIMPORT void WFG9(double *z, double *f,int nx,int M)
{
	int i,j;	
	double y[30],t1[30],t2[30],t3[5];
	const int k=M==2?4:2*(M-1);
	
	for( i = 0; i < nx; i++ )
	{		
		y[i] = z[i] / (2.0*( i+1 ));
	}		
	
	for( i = 0; i < nx-1; i++ )
	{
		const int head = i+1;
		const int tail = nx;
		double y_sub[30],w_sub[30];	
		for( j = head; j < tail; j++ )
		{
			y_sub[j-head] = y[j];
			w_sub[j-head] = 1;
		}		
		{
			const double u = r_sum( y_sub, w_sub, tail-head );			
			t1[i] = b_param( y[i], u, 0.98/49.98, 0.02, 50 );
		}
	}
	t1[nx-1]=y[nx-1];
	
	//y= WFG9_t2( y, k);
	for( i = 0; i < k; i++ )
	{
		t2[i] = s_decept( t1[i], 0.35, 0.001, 0.05 );
	}
	
	for( i = k; i < nx; i++ )
	{
		t2[i] = s_multi( t1[i], 30, 95, 0.35 );
	}
	//y= WFG6_t2( y, k, M);
	for( i = 1; i <= M-1; i++ )
	{
		const int head = ( i-1 )*k/( M-1 );
		const int tail = i*k/( M-1 );
		double y_sub[30];		
		for( j = head; j < tail; j++ )
		{
			y_sub[j-head] = t2[j];			
		}	
		
		t3[i-1] = r_nonsep( y_sub, k/( M-1 ),tail-head );
	}
	
	{
		double y_sub2[30];		
		for( j = k; j < nx; j++ )
		{
			y_sub2[j-k] = t2[j];			
		}	
		
		t3[M-1] = r_nonsep( y_sub2, nx-k, nx-k );
	}
	
	//f_result=WFG4_shape(y);
	{
		int  m;	
		short  A[5];
		double x[5],h[5],S[5];		
		
		A[0] = 1;	
		for( i = 1; i < M-1; i++ )
		{
			A[i] = 1;
		}
		for( i = 0; i < M-1; i++ )
		{
			double tmp1;		
			tmp1 = t3[M-1];
			if( A[i] > tmp1 )
				tmp1 = A[i];		
			x[i] = tmp1*( t3[i] - 0.5 ) + 0.5;
		}	
		x[M-1] = t3[M-1];
		
		for( m = 1; m <= M; m++ )
		{
			h[m-1] = concave( x, m,M );
		}
		for( m = 1; m <= M; m++ )
		{
			S[m-1] = m*2.0;
		}
		
		for( i = 0; i < M; i++ )
		{		
			f[i] = 1.0*x[M-1] + S[i]*h[i];
		}		
	}	
}
